#include "sdf_shapes.sumi"

// 1. The Map Function (Defines the Scene)
fn map(p: vec3) float {
    // A sphere pulsing in size
    float dSphere = sdSphere(p - vec3(0.0, 0.0, 0.0), 1.0);
    
    // A box rotating around it
    vec3 q = p - vec3(sin(iTime), 0.0, cos(iTime));
    
    // Note: We haven't moved sdBox or opSmoothUnion to .sumi files yet,
    // so we can't use them here unless we define them or uncomment them in stdlib.wgsl.
    // For this modular test, let's keep it simple: just the sphere!
    
    return dSphere;
}

// 2. The Main Image (Raymarcher)
fn mainImage(fragCoord: vec2) vec4 {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec3 ro = vec3(0.0, 0.0, 3.0); 
    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));
    
    float t = 0.0;
    float d = 0.0;
    vec3 p = vec3(0.0, 0.0, 0.0);
    
    for (int i = 0; i < 80; i = i + 1) {
        p = ro + rd * t;
        d = map(p);
        
        if (d < 0.001) { break; } 
        if (t > 10.0) { break; }  
        
        t = t + d;
    }
    
    vec3 col = vec3(0.0, 0.0, 0.0);
    if (t < 10.0) {
        // Simple lighting
        vec3 light = normalize(vec3(1.0, 1.0, 1.0));
        // We need a normal. For now, flat shading based on position (fake normal)
        vec3 n = normalize(p); 
        float diff = max(dot(n, light), 0.0);
        col = vec3(1.0, 0.5, 0.2) * diff + vec3(0.1, 0.1, 0.2);
    }

    return vec4(col, 1.0);
}
