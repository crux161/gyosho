#include "sdf_primitives.sumi"

// --- Logic ---

fn opU(d1: vec2, d2: vec2) vec2 {
    if (d1.x < d2.x) { return d1; }
    return d2;
}

fn map(pos: vec3) vec2 {
    vec2 res = vec2(pos.y, 0.0);

    // Bounding Box 1
    if (sdBox(pos - vec3(-2.0, 0.3, 0.25), vec3(0.3, 0.3, 1.0)) < res.x) {
        res = opU(res, vec2(sdSphere(pos - vec3(-2.0, 0.25, 0.0), 0.25), 26.9));
        res = opU(res, vec2(sdRhombus((pos - vec3(-2.0, 0.25, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08), 17.0));
    }

    // Bounding Box 2
    if (sdBox(pos - vec3(0.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x) {
        res = opU(res, vec2(sdCappedTorus((pos - vec3(0.0, 0.30, 1.0)) * vec3(1.0, -1.0, 1.0), vec2(0.866025, -0.5), 0.25, 0.05), 25.0));
        res = opU(res, vec2(sdBoxFrame(pos - vec3(0.0, 0.25, 0.0), vec3(0.3, 0.25, 0.2), 0.025), 16.9));
        res = opU(res, vec2(sdCone(pos - vec3(0.0, 0.45, -1.0), vec2(0.6, 0.8), 0.45), 55.0));
        res = opU(res, vec2(sdCappedCone(pos - vec3(0.0, 0.25, -2.0), 0.25, 0.25, 0.1), 13.67));
        res = opU(res, vec2(sdSolidAngle(pos - vec3(0.0, 0.00, -3.0), vec2(3.0, 4.0) / 5.0, 0.4), 49.13));
    }

    // Bounding Box 3
    if (sdBox(pos - vec3(1.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x) {
        res = opU(res, vec2(sdTorus((pos - vec3(1.0, 0.30, 1.0)).xzy, vec2(0.25, 0.05)), 7.1));
        res = opU(res, vec2(sdBox(pos - vec3(1.0, 0.25, 0.0), vec3(0.3, 0.25, 0.1)), 3.0));
        res = opU(res, vec2(sdCapsule(pos - vec3(1.0, 0.00, -1.0), vec3(-0.1, 0.1, -0.1), vec3(0.2, 0.4, 0.2), 0.1), 31.9));
        res = opU(res, vec2(sdCylinder(pos - vec3(1.0, 0.25, -2.0), vec2(0.15, 0.25)), 8.0));
        res = opU(res, vec2(sdHexPrism(pos - vec3(1.0, 0.2, -3.0), vec2(0.2, 0.05)), 18.4));
    }
    
    // Bounding Box 4
    if (sdBox(pos - vec3(-1.0, 0.35, -1.0), vec3(0.35, 0.35, 2.5)) < res.x) {
        res = opU(res, vec2(sdPyramid(pos - vec3(-1.0, -0.6, -3.0), 1.0), 13.56));
        res = opU(res, vec2(sdOctahedron(pos - vec3(-1.0, 0.15, -2.0), 0.35), 23.56));
        res = opU(res, vec2(sdTriPrism(pos - vec3(-1.0, 0.15, -1.0), vec2(0.3, 0.05)), 43.5));
        res = opU(res, vec2(sdEllipsoid(pos - vec3(-1.0, 0.25, 0.0), vec3(0.2, 0.25, 0.05)), 43.17));
        res = opU(res, vec2(sdHorseshoe(pos - vec3(-1.0, 0.25, 1.0), vec2(cos(1.3), sin(1.3)), 0.2, 0.3, vec2(0.03, 0.08)), 11.5));
    }

    // Bounding Box 5
    if (sdBox(pos - vec3(2.0, 0.3, -1.0), vec3(0.35, 0.3, 2.5)) < res.x) {
        res = opU(res, vec2(sdOctogonPrism(pos - vec3(2.0, 0.2, -3.0), 0.2, 0.05), 51.8));
        res = opU(res, vec2(sdRoundCone(pos - vec3(2.0, 0.20, 1.0), 0.2, 0.1, 0.3), 37.0));
    }

    return res;
}

fn iBox(ro: vec3, rd: vec3, rad: vec3) vec2 {
    vec3 m = 1.0 / rd;
    vec3 n = m * ro;
    vec3 k = abs(m) * rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));
}

fn raycast(ro: vec3, rd: vec3) vec2 {
    vec2 res = vec2(-1.0, -1.0);
    float tmin = 1.0;
    float tmax = 20.0;

    float tp1 = (0.0 - ro.y) / rd.y;
    if (tp1 > 0.0) {
        tmax = min(tmax, tp1);
        res = vec2(tp1, 1.0);
    }
    
    vec2 tb = iBox(ro - vec3(0.0, 0.4, -0.5), rd, vec3(2.5, 0.41, 3.0));
    if (tb.x < tb.y) {
        if (tb.y > 0.0) {
            if (tb.x < tmax) {
                tmin = max(tb.x, tmin);
                tmax = min(tb.y, tmax);

                float t = tmin;
                for (var i: i32 = 0; i < 70; i = i + 1) {
                    if (t >= tmax) { break; }
                    
                    vec2 h = map(ro + rd * t);
                    if (abs(h.x) < (0.0001 * t)) {
                        res = vec2(t, h.y);
                        break;
                    }
                    t = t + h.x;
                }
            }
        }
    }
    return res;
}

fn calcSoftshadow(ro: vec3, rd: vec3, mint: float, tmax: float) float {
    float tp = (0.8 - ro.y) / rd.y;
    
    float tmax_inner = tmax;
    if (tp > 0.0) { tmax_inner = min(tmax, tp); }
    
    float res = 1.0;
    float t = mint;
    
    for (var i: i32 = 0; i < 24; i = i + 1) {
        float h = map(ro + rd * t).x;
        float s = clamp(8.0 * h / t, 0.0, 1.0);
        res = min(res, s);
        t = t + clamp(h, 0.01, 0.2);
        
        if (res < 0.004) { break; }
        if (t > tmax_inner) { break; }
    }
    res = clamp(res, 0.0, 1.0);
    return res * res * (3.0 - 2.0 * res);
}

fn calcNormal(pos: vec3) vec3 {
    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;
    
    vec3 e_xyy = vec3(e.x, e.y, e.y);
    vec3 e_yyx = vec3(e.y, e.y, e.x);
    vec3 e_yxy = vec3(e.y, e.x, e.y);
    vec3 e_xxx = vec3(e.x, e.x, e.x);
    
    return normalize(
        e_xyy * map(pos + e_xyy).x +
        e_yyx * map(pos + e_yyx).x +
        e_yxy * map(pos + e_yxy).x +
        e_xxx * map(pos + e_xxx).x
    );
}

fn calcAO(pos: vec3, nor: vec3) float {
    float occ = 0.0;
    float sca = 1.0;
    for (var i: i32 = 0; i < 5; i = i + 1) {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = map(pos + h * nor).x;
        occ = occ + (h - d) * sca;
        sca = sca * 0.95;
        if (occ > 0.35) { break; }
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);
}

fn checkersGradBox(p: vec2, dpdx: vec2, dpdy: vec2) float {
    vec2 w = abs(dpdx) + abs(dpdy) + vec2(0.001, 0.001);
    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;
    return 0.5 - 0.5 * i.x * i.y;
}

fn render(ro: vec3, rd: vec3) vec3 {
    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;
    
    vec2 res = raycast(ro, rd);
    float t = res.x;
    float m = res.y;
    
    if (m > -0.5) {
        vec3 pos = ro + t * rd;
        
        vec3 nor = vec3(0.0, 1.0, 0.0);
        if (m >= 1.5) { nor = calcNormal(pos); }
        
        // FIX: 'ref' -> 'refl'
        vec3 refl = reflect(rd, nor);
        
        col = vec3(0.2, 0.2, 0.2) + 0.2 * sin(m * 2.0 + vec3(0.0, 1.0, 2.0));
        float ks = 1.0;
        
        if (m < 1.5) {
            float f = checkersGradBox(3.0 * pos.xz, vec2(0.0, 0.0), vec2(0.0, 0.0));
            col = vec3(0.15, 0.15, 0.15) + f * vec3(0.05, 0.05, 0.05);
            ks = 0.4;
        }
        
        float occ = calcAO(pos, nor);
        vec3 lin = vec3(0.0, 0.0, 0.0);
        
        // Sun
        vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));
        vec3 hal = normalize(lig - rd);
        float dif = clamp(dot(nor, lig), 0.0, 1.0);
        
        dif = dif * calcSoftshadow(pos, lig, 0.02, 2.5);
        
        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);
        spe = spe * dif;
        spe = spe * (0.04 + 0.96 * pow(clamp(1.0 - dot(hal, lig), 0.0, 1.0), 5.0));
        
        lin = lin + col * 2.20 * dif * vec3(1.30, 1.00, 0.70);
        lin = lin + 5.00 * spe * vec3(1.30, 1.00, 0.70) * ks;
        
        // Sky
        float dif2 = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));
        dif2 = dif2 * occ;
        float spe2 = smoothstep(-0.2, 0.2, refl.y); // Fixed variable name
        spe2 = spe2 * dif2;
        spe2 = spe2 * (0.04 + 0.96 * pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 5.0));
        spe2 = spe2 * calcSoftshadow(pos, refl, 0.02, 2.5); // Fixed variable name
        
        lin = lin + col * 0.60 * dif2 * vec3(0.40, 0.60, 1.15);
        lin = lin + 2.00 * spe2 * vec3(0.40, 0.60, 1.30) * ks;
        
        // Back
        float dif3 = clamp(dot(nor, normalize(vec3(0.5, 0.0, 0.6))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);
        dif3 = dif3 * occ;
        lin = lin + col * 0.55 * dif3 * vec3(0.25, 0.25, 0.25);
        
        // SSS
        float dif4 = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);
        dif4 = dif4 * occ;
        lin = lin + col * 0.25 * dif4 * vec3(1.00, 1.00, 1.00);
        
        col = lin;
        col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));
    }
    
    return clamp(col, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
}

fn setCamera(ro: vec3, ta: vec3, cr: float) mat3 {
    vec3 cw = normalize(ta - ro);
    vec3 cp = vec3(sin(cr), cos(cr), 0.0);
    vec3 cu = normalize(cross(cw, cp));
    vec3 cv = cross(cu, cw);
    return mat3(cu, cv, cw);
}

fn mainImage(fragCoord: vec2) vec4 {
    // REVERTED: Using Raw coordinates (No Flip)
    // Hanga (wgpu) = Bottom-Left Origin for standard clip space
    
    vec2 mo = iMouse.xy / iResolution.xy;
    float time = 32.0 + iTime * 1.5;
    
    vec3 ta = vec3(0.25, -0.75, -0.75);
    vec3 ro = ta + vec3(4.5 * cos(0.1 * time + 7.0 * mo.x), 2.2, 4.5 * sin(0.1 * time + 7.0 * mo.x));
    
    mat3 ca = setCamera(ro, ta, 0.0);
    
    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;
    
    float fl = 2.5;
    vec3 rd = ca * normalize(vec3(p.x, p.y, fl));
    
    vec3 col = render(ro, rd);
    
    col = pow(col, vec3(0.4545, 0.4545, 0.4545));
    
    // Final Gamma correction for Hanga display
    col = pow(col, vec3(2.2, 2.2, 2.2));
    
    return vec4(col.x, col.y, col.z, 1.0);
}
