// --- SDF Primitives Library (WGSL Safe) ---

// Helpers
fn dot2_v2(v: vec2) float { return dot(v,v); }
fn dot2_v3(v: vec3) float { return dot(v,v); }
fn ndot(a: vec2, b: vec2) float { return a.x*b.x - a.y*b.y; }

// Primitives
fn sdPlane(p: vec3) float {
    return p.y;
}

fn sdSphere(p: vec3, s: float) float {
    return length(p) - s;
}

fn sdBox(p: vec3, b: vec3) float {
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, vec3(0.0, 0.0, 0.0)));
}

fn sdBoxFrame(p: vec3, b: vec3, e: float) float {
    vec3 p_abs = abs(p) - b;
    vec3 q_abs = abs(p + e) - e;
    
    return min(min(
        length(max(vec3(p_abs.x, q_abs.y, q_abs.z), vec3(0.0,0.0,0.0))) + min(max(p_abs.x, max(q_abs.y, q_abs.z)), 0.0),
        length(max(vec3(q_abs.x, p_abs.y, q_abs.z), vec3(0.0,0.0,0.0))) + min(max(q_abs.x, max(p_abs.y, q_abs.z)), 0.0)),
        length(max(vec3(q_abs.x, q_abs.y, p_abs.z), vec3(0.0,0.0,0.0))) + min(max(q_abs.x, max(q_abs.y, p_abs.z)), 0.0));
}

fn sdEllipsoid(p: vec3, r: vec3) float {
    float k0 = length(p/r);
    float k1 = length(p/(r*r));
    return k0 * (k0 - 1.0) / k1;
}

fn sdTorus(p: vec3, t: vec2) float {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

fn sdCappedTorus(p: vec3, sc: vec2, ra: float, rb: float) float {
    vec3 p2 = p;
    p2.x = abs(p2.x);
    float k = length(p2.xy);
    if (sc.y*p2.x > sc.x*p2.y) {
        k = dot(p2.xy, sc);
    }
    return sqrt(dot(p2,p2) + ra*ra - 2.0*ra*k) - rb;
}

fn sdHexPrism(p: vec3, h: vec2) float {
    vec3 k = vec3(-0.8660254, 0.5, 0.57735);
    vec3 p2 = abs(p);
    
    // FIX: Manual swizzle assignment
    vec2 p2_xy = p2.xy - 2.0 * min(dot(k.xy, p2.xy), 0.0) * k.xy;
    p2.x = p2_xy.x;
    p2.y = p2_xy.y;
    
    vec2 d = vec2(
       length(p2.xy - vec2(clamp(p2.x, -k.z*h.x, k.z*h.x), h.x)) * sign(p2.y - h.x),
       p2.z - h.y
    );
    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0, 0.0)));
}

fn sdOctogonPrism(p: vec3, r: float, h: float) float {
    vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623);
    vec3 p2 = abs(p);
    
    // FIX: Manual swizzle 1
    vec2 p2_xy_1 = p2.xy - 2.0 * min(dot(vec2(k.x, k.y), p2.xy), 0.0) * vec2(k.x, k.y);
    p2.x = p2_xy_1.x;
    p2.y = p2_xy_1.y;

    // FIX: Manual swizzle 2
    vec2 p2_xy_2 = p2.xy - 2.0 * min(dot(vec2(-k.x, k.y), p2.xy), 0.0) * vec2(-k.x, k.y);
    p2.x = p2_xy_2.x;
    p2.y = p2_xy_2.y;
    
    // FIX: Manual swizzle 3
    vec2 p2_xy_3 = p2.xy - vec2(clamp(p2.x, -k.z*r, k.z*r), r);
    p2.x = p2_xy_3.x;
    p2.y = p2_xy_3.y;
    
    vec2 d = vec2(length(p2.xy)*sign(p2.y), p2.z - h);
    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0, 0.0)));
}

fn sdCapsule(p: vec3, a: vec3, b: vec3, r: float) float {
    vec3 pa = p - a;
    vec3 ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h) - r;
}

fn sdRoundCone(p: vec3, r1: float, r2: float, h: float) float {
    vec2 q = vec2(length(p.xz), p.y);
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q, vec2(-b, a));
    
    if(k < 0.0) { return length(q) - r1; }
    if(k > a*h) { return length(q - vec2(0.0, h)) - r2; }
    
    return dot(q, vec2(a, b)) - r1;
}

fn sdTriPrism(p: vec3, h: vec2) float {
    float k = sqrt(3.0);
    vec2 h2 = h;
    h2.x = h2.x * 0.5 * k;
    
    vec3 p2 = p;
    
    // FIX: Manual swizzle
    vec2 p2_xy = p2.xy / h2.x;
    p2.x = p2_xy.x;
    p2.y = p2_xy.y;
    
    p2.x = abs(p2.x) - 1.0;
    p2.y = p2.y + 1.0/k;
    
    if(p2.x + k*p2.y > 0.0) {
        // FIX: Manual swizzle
        vec2 p2_xy_2 = vec2(p2.x - k*p2.y, -k*p2.x - p2.y) / 2.0;
        p2.x = p2_xy_2.x;
        p2.y = p2_xy_2.y;
    }
    
    p2.x = p2.x - clamp(p2.x, -2.0, 0.0);
    
    float d1 = length(p2.xy) * sign(-p2.y) * h2.x;
    float d2 = abs(p2.z) - h2.y;
    return length(max(vec2(d1, d2), vec2(0.0, 0.0))) + min(max(d1, d2), 0.0);
}

fn sdCylinder(p: vec3, h: vec2) float {
    vec2 d = abs(vec2(length(p.xz), p.y)) - h;
    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0, 0.0)));
}

fn sdCone(p: vec3, c: vec2, h: float) float {
    vec2 q = h * vec2(c.x, -c.y) / c.y;
    vec2 w = vec2(length(p.xz), p.y);
    
    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
    
    float k = sign(q.y);
    float d = min(dot(a, a), dot(b, b));
    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
    
    return sqrt(d) * sign(s);
}

fn sdCappedCone(p: vec3, h: float, r1: float, r2: float) float {
    vec2 q = vec2(length(p.xz), p.y);
    vec2 k1 = vec2(r2, h);
    vec2 k2 = vec2(r2 - r1, 2.0 * h);
    
    float r_select = r2;
    if (q.y < 0.0) { r_select = r1; }
    
    vec2 ca = vec2(q.x - min(q.x, r_select), abs(q.y) - h);
    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2_v2(k2), 0.0, 1.0);
    
    float s = 1.0;
    if (cb.x < 0.0) { if (ca.y < 0.0) { s = -1.0; } }
    
    return s * sqrt(min(dot2_v2(ca), dot2_v2(cb)));
}

fn sdSolidAngle(pos: vec3, c: vec2, ra: float) float {
    vec2 p = vec2(length(pos.xz), pos.y);
    float l = length(p) - ra;
    float m = length(p - c * clamp(dot(p, c), 0.0, ra));
    return max(l, m * sign(c.y * p.x - c.x * p.y));
}

fn sdOctahedron(p: vec3, s: float) float {
    vec3 p2 = abs(p);
    float m = p2.x + p2.y + p2.z - s;
    
    vec3 q;
    if (3.0 * p2.x < m) { q = p2.xyz; }
    else { 
        if (3.0 * p2.y < m) { q = p2.yzx; }
        else {
            if (3.0 * p2.z < m) { q = p2.zxy; }
            else { return m * 0.57735027; }
        }
    }
    
    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);
    return length(vec3(q.x, q.y - s + k, q.z - k));
}

fn sdPyramid(p: vec3, h: float) float {
    float m2 = h * h + 0.25;
    vec3 p2 = p;
    p2.x = abs(p2.x);
    p2.z = abs(p2.z);
    
    if (p2.z > p2.x) { 
        float temp = p2.x; p2.x = p2.z; p2.z = temp;
    }
    
    p2.x = p2.x - 0.5;
    p2.z = p2.z - 0.5;
    
    vec3 q = vec3(p2.z, h * p2.y - 0.5 * p2.x, h * p2.x + 0.5 * p2.y);
    
    float s = max(-q.x, 0.0);
    float t = clamp((q.y - 0.5 * p2.z) / (m2 + 0.25), 0.0, 1.0);
    
    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;
    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);
    
    float d2 = min(a, b);
    if (min(q.y, -q.x * m2 - q.y * 0.5) > 0.0) { d2 = 0.0; }
    
    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p2.y));
}

fn sdRhombus(p: vec3, la: float, lb: float, h: float, ra: float) float {
    vec3 p2 = abs(p);
    vec2 b = vec2(la, lb);
    float f = clamp((ndot(b, b - 2.0 * p2.xz)) / dot(b, b), -1.0, 1.0);
    
    vec2 q = vec2(length(p2.xz - 0.5 * b * vec2(1.0 - f, 1.0 + f)) * sign(p2.x * b.y + p2.z * b.x - b.x * b.y) - ra, p2.y - h);
    
    return min(max(q.x, q.y), 0.0) + length(max(q, vec2(0.0, 0.0)));
}

fn sdHorseshoe(p: vec3, c: vec2, r: float, le: float, w: vec2) float {
    vec3 p2 = p;
    p2.x = abs(p2.x);
    float l = length(p2.xy);
    
    // FIX: Manual swizzle
    vec2 p_xy_new = vec2(
        -c.x * p2.x + c.y * p2.y,
        c.y * p2.x + c.x * p2.y
    );
    p2.x = p_xy_new.x;
    p2.y = p_xy_new.y;
    
    float target_x = p2.x;
    if (p2.y <= 0.0) { if (p2.x <= 0.0) { target_x = l * sign(-c.x); } }
    
    float target_y = l;
    if (p2.x > 0.0) { target_y = p2.y; }
    
    p2.x = target_x;
    p2.y = target_y;
    
    p2.x = p2.x - le;
    p2.y = abs(p2.y - r);
    
    vec2 q = vec2(length(max(p2.xy, vec2(0.0, 0.0))) + min(0.0, max(p2.x, p2.y)), p2.z);
    vec2 d = abs(q) - w;
    
    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0, 0.0)));
}
