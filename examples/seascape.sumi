// Seascape Port (Restored Orientation)

// --- Helpers ---

fn mix_v(x: vec2, y: vec2, a: vec2) vec2 {
    return vec2(mix(x.x, y.x, a.x), mix(x.y, y.y, a.y));
}

fn fromEuler(ang: vec3) mat3 {
    vec2 a1 = vec2(sin(ang.x), cos(ang.x));
    vec2 a2 = vec2(sin(ang.y), cos(ang.y));
    vec2 a3 = vec2(sin(ang.z), cos(ang.z));
    
    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
    vec3 m1 = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
    
    return mat3(m0, m1, m2);
}

fn hash(p: vec2) float {
    // We must use a temporary var because assignment to args is tricky in some backends
    vec2 p2 = fract(p * 0.3183099 + 0.1);
    p2 = p2 * 17.0;
    return fract(p2.x * p2.y * (p2.x + p2.y));
}

fn noise(p: vec2) float {
    vec2 i = floor(p);
    vec2 f = fract(p);    
    vec2 u = f * f * (3.0 - 2.0 * f);
    
    float a = hash(i + vec2(0.0, 0.0));
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    
    return -1.0 + 2.0 * mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

fn diffuse(n: vec3, l: vec3, p: float) float {
    return pow(dot(n, l) * 0.4 + 0.6, p);
}

fn specular(n: vec3, l: vec3, e: vec3, s: float) float {    
    float nrm = (s + 8.0) / (3.14159 * 8.0);
    return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
}

fn getSkyColor(e: vec3) vec3 {
    float y = (max(e.y, 0.0) * 0.8 + 0.2) * 0.8;
    return vec3(pow(1.0 - y, 2.0), 1.0 - y, 0.6 + (1.0 - y) * 0.4) * 1.1;
}

fn sea_octave(uv: vec2, choppy: float) float {
    vec2 uv2 = uv + noise(uv);        
    vec2 wv = 1.0 - abs(sin(uv2));
    vec2 swv = abs(cos(uv2));    
    vec2 wv2 = mix_v(wv, swv, wv);
    return pow(1.0 - pow(wv2.x * wv2.y, 0.65), choppy);
}

// --- Map Functions ---

fn map(p: vec3) float {
    float freq = 0.16;
    float amp = 0.6;
    float choppy = 4.0;
    vec2 uv = vec2(p.x, p.z); 
    uv.x = uv.x * 0.75;
    
    float sea_time = 1.0 + iTime * 0.8;
    
    float d = 0.0;
    float h = 0.0;    
    for(var i: i32 = 0; i < 3; i = i + 1) {        
        d = sea_octave((uv + sea_time) * freq, choppy);
        d = d + sea_octave((uv - sea_time) * freq, choppy);
        h = h + d * amp;        
        
        vec2 uv_next = vec2(1.6 * uv.x - 1.2 * uv.y, 1.2 * uv.x + 1.6 * uv.y);
        uv = uv_next;
        
        freq = freq * 1.9; 
        amp = amp * 0.22;
        choppy = mix(choppy, 1.0, 0.2);
    }
    return p.y - h;
}

fn map_detailed(p: vec3) float {
    float freq = 0.16;
    float amp = 0.6;
    float choppy = 4.0;
    vec2 uv = vec2(p.x, p.z); 
    uv.x = uv.x * 0.75;
    
    float sea_time = 1.0 + iTime * 0.8;
    
    float d = 0.0;
    float h = 0.0;    
    for(var i: i32 = 0; i < 5; i = i + 1) {        
        d = sea_octave((uv + sea_time) * freq, choppy);
        d = d + sea_octave((uv - sea_time) * freq, choppy);
        h = h + d * amp;        
        
        vec2 uv_next = vec2(1.6 * uv.x - 1.2 * uv.y, 1.2 * uv.x + 1.6 * uv.y);
        uv = uv_next;
        
        freq = freq * 1.9; 
        amp = amp * 0.22;
        choppy = mix(choppy, 1.0, 0.2);
    }
    return p.y - h;
}

// --- Rendering ---

fn getSeaColor(p: vec3, n: vec3, l: vec3, eye: vec3, dist: vec3) vec3 {  
    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
    fresnel = min(fresnel * fresnel * fresnel, 0.5);
    
    vec3 reflected = getSkyColor(reflect(eye, n));    
    vec3 refracted = vec3(0.0, 0.09, 0.18) + diffuse(n, l, 80.0) * vec3(0.48, 0.54, 0.36) * 0.12; 
    
    vec3 color = mix(refracted, reflected, fresnel);
    
    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
    color = color + vec3(0.48, 0.54, 0.36) * (p.y - 0.6) * 0.18 * atten;
    
    float dist_sq = dot(dist, dist);
    
    color = color + specular(n, l, eye, 600.0 * (1.0 / sqrt(dist_sq)));
    
    return color;
}

fn getNormal(p: vec3, eps: float) vec3 {
    vec3 n = vec3(0.0, 0.0, 0.0);
    n.y = map_detailed(p);    
    n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;
    n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;
    n.y = eps;
    return normalize(n);
}

fn heightMapTracing(ori: vec3, dir: vec3) float {  
    float tm = 0.0;
    float tx = 1000.0;    
    float hx = map(ori + dir * tx);
    if(hx > 0.0) {
        return tx;    
    }
    float hm = map(ori);    
    for(var i: i32 = 0; i < 32; i = i + 1) {
        float tmid = mix(tm, tx, hm / (hm - hx));
        vec3 p = ori + dir * tmid;
        float hmid = map(p);        
        if(hmid < 0.0) {
            tx = tmid;
            hx = hmid;
        } else {
            tm = tmid;
            hm = hmid;
        }        
        if(abs(hmid) < 0.001) { break; }
    }
    return mix(tm, tx, hm / (hm - hx));
}

fn getPixel(coord: vec2) vec3 {    
    vec2 uv = coord / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x = uv.x * (iResolution.x / iResolution.y);    
        
    vec3 ang = vec3(sin(iTime * 3.0) * 0.1, sin(iTime) * 0.2 + 0.3, iTime);    
    vec3 ori = vec3(0.0, 3.5, iTime * 5.0);
    vec3 dir = normalize(vec3(uv.x, uv.y, -2.0)); 
    dir.z = dir.z + length(uv) * 0.14;
    
    mat3 rot = fromEuler(ang);
    vec3 d = normalize(dir);
    
    dir = vec3( dot(d, rot[0]), dot(d, rot[1]), dot(d, rot[2]) );
    
    float t = heightMapTracing(ori, dir);
    vec3 p = ori + dir * t;
    vec3 dist = p - ori;
    
    float EPSILON_NRM = 0.1 / iResolution.x;
    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);
    vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
             
    return mix(
        getSkyColor(dir),
        getSeaColor(p, n, light, dir, dist),
        pow(smoothstep(0.0, -0.02, dir.y), 0.2)
    );
}

fn mainImage(fragCoord: vec2) vec4 {
    // REVERTED: Pass fragCoord directly (No Flip)
    vec3 color = getPixel(fragCoord);
    
    // KEEP: Gamma Correction (Linear -> sRGB darkening)
    color = pow(color, vec3(2.2, 2.2, 2.2));
    
    return vec4(color.x, color.y, color.z, 1.0);
}
